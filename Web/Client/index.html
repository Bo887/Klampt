<!DOCTYPE html>
<html>
   <head>
      <title>Klampt Three.js app</title>
      <meta charset="UTF-8">

      <script src="w2ui/libs/jquery/jquery-2.1.4.min.js"></script>

      <link rel="stylesheet" type="text/css" href="w2ui/dist/w2ui.min.css" />
      <script type="text/javascript" src="w2ui/dist/w2ui.min.js"></script>

      <script src="three.js/build/three.min.js"></script> 
      <script src="three.js/examples/js/controls/TrackballControls.js"></script> 

      <script src="stats.js/build/stats.min.js"></script>

      <script src="DaveWebsocket.js"></script> 
          
      <!--
      <link rel="stylesheet" href="CodeMirror-master/lib/codemirror.css">
      <link rel="stylesheet" href="CodeMirror-master/addon/hint/show-hint.css">
         
      <script src="CodeMirror-master/lib/codemirror.js"></script>
      <script src="CodeMirror-master/addon/hint/show-hint.js"></script>
      <script src="CodeMirror-master/mode/python/python.js"></script>
      -->
      
      <script src="ace-builds/src-noconflict/ace.js"></script>
      <script src="ace-builds/src-noconflict/ext-language_tools.js"></script>
   
   </head>
    
   <body style="margin: 0px;">
      <div id="myLayout" style="position: absolute; top: 0; right: 0; bottom: 0; left: 0;"></div>
   
            
      <script>
         //var stats = new Stats();
			//stats.showPanel( 0 );
			//document.body.appendChild( stats.dom );
         
         var scene = new THREE.Scene();
         var camera = new THREE.PerspectiveCamera( 75, 1.0, 0.1, 1000 );
         camera.position.z = 10;
         camera.position.y = 5;
   
         var renderer = new THREE.WebGLRenderer();  
         var loader = new THREE.ObjectLoader();
   
         var network; 
         var editor;
         var visPanel;
         var freeRun=false;
         var localStorageAvailable=false;
         var localStorage;
         
         function storageAvailable()
         {
            try {
               localStorage = window['localStorage'],
                  x = '__storage_test__';
               localStorage.setItem(x, x);
               localStorage.removeItem(x);
               return true;
            }
            catch(e) {
               console.log("looks like storage is not setup: " + e);
               return false;
            }
         }        
                 
         function doCodeSubmit()
         {
            var textArea=document.getElementById("myTextarea");
            textArea.value="> ";
             
            if(localStorageAvailable)
            {
             localStorage.setItem('KlamptExample1', editor.getValue());           
            }
            sendCode();     
         }
         function requestStop()
         {
            freeRun=false;
         }
         function requestAdvance()
         {
            sendMessage("A");
         }
         function requestFreeRun()
         {
            requestAdvance();
            freeRun=true;
         }
     
         $( document ).ready(function() {
            console.log("page is ready, lets setup some stuff");
            console.log("first testing if local storage is available");
            localStorageAvailable=storageAvailable();
            console.log("  local storage test determined: " + localStorageAvailable);
 
            var pstyle = 'background-color: #F5F6F7; border: 1px solid #dfdfdf; padding: 5px;';
            $('#myLayout').w2layout({
               name: 'layout',
               panels: [
                  { type: 'top',  size: "5%", resizable: true, style: pstyle, content: '<button onclick="doCodeSubmit()">Submit Code</button><button onclick="requestAdvance()">Advance Frame</button><button onclick="requestFreeRun()">Run</button><button onclick="requestStop()">Stop</button> <div style=" width:20px;display:inline-block;" />Klampt Server URL:<input type="text" id="serverURL" value="ws://l33t.egr.duke.edu:1234" size="50"><button onclick="doConnect()">Connect</button>'},
                  { type: 'main', style: pstyle, content: '<div id="canvas" style="width:100%; height:100%; margin:0; padding:0"></div>' },
                  { type: 'preview', size: "15%", resizable: true, style: pstyle, content: '<textarea readonly id="myTextarea" style="background-color: black;color:white;width:100%;height:100%">> </textarea></div></div>' },
                  { type: 'right', size: '50%', resizable: true, style: pstyle, content: 
                    '<div id="editor" style="width:100%; height:100%; margin:0; padding:0"></div>' },               ]
            });
            
          
            
            
          

            ace.require("ace/ext/language_tools"); //setup the text editor
            editor = ace.edit("editor");
      
            editor.setOptions({
               enableBasicAutocompletion: true,
               enableSnippets: false,
               enableLiveAutocompletion: false,
               showPrintMargin: false
            });
      
            editor.setTheme("ace/theme/eclipse"); 
            editor.getSession().setMode("ace/mode/python");
            
            editor.getSession().setValue("nextTime = 1\ntoggle = 0\ndef init(robot_model):\n    global ghost\n    ghost=kviz.add_ghost('myGhost')\n    kviz.set_color(ghost,[1,0,0,0.25],True)\n    q=kviz.get_robot_config()\n    q[8]-=2.0\n    kviz.set_ghost_config(q,'myGhost')\n    kviz.add_text('HUD1',1,1)\n    kviz.update_text('HUD1','hello world')\n\ndef control_loop(t,controller):\n    global nextTime, toggle\n    if t >= nextTime:\n        q = controller.getCommandedConfig()\n        q[8] -= 0.5\n        controller.setMilestone(q)\n        nextTime += 1.0\n        ");
            
            if(localStorageAvailable) //lets see if we have worked on this previously
            {
               var example1Text=localStorage.getItem('KlamptExample1');
               if(example1Text!=null)
               {
                  editor.getSession().setValue(example1Text);
               }
            }
                       
            //var editor = CodeMirror( document.getElementById("editor"), { //use codemirror as text editor
            //value: "print 'hello world'\n",
            //mode:  "python",
            //lineNumbers: true,
            //autohint: true,
            //hint: true
            //});

            w2ui.layout.on('resize', function(event) { //make sure three.js canvas resizes when sub-window size changes
               event.onComplete = function () {
                  console.log("resize completed"); 
                  onWindowResize(event);
               }
            });
 
            visPanel=w2ui['layout'].get('main');   
     
            container = document.getElementById("canvas");
            renderer.setClearColor(0x88888888);
            container.appendChild( renderer.domElement );  //attach the three.js renderer to the proper div 


            
            controls=new THREE.TrackballControls( camera, container);
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;
                controls.keys = [ 65, 83, 68 ];
            controls.addEventListener( 'change', render );   
                         
            onWindowResize();
            animate();       
         });
         
         function doConnect()
         {
            var URL=$('#serverURL').val();
            console.log("trying to connect to URL: " + URL);
            network = new Network(URL,newSceneArrivedCallback,consoleTextArrivedCallback,consoleTextArrivedCallback);         
         }
   
         function sendCode() //send python code back to server
         {
            console.log("got request to send code!\n");
            console.log("trying to send: " + editor.getValue());
            sendMessage(editor.getValue());
            //sendMessage("hello world");
         }
            
         function onWindowResize( event )
         {
            console.log("onWindowResize");
         
            mWidth= visPanel.width-11; //account for 5px padding on each side
            mHeight=visPanel.height-11;
         
            console.log("width: " + mWidth + " height: " + mHeight);
            renderer.setSize(mWidth,mHeight );
            camera.aspect =mWidth/ mHeight;
               
            camera.updateProjectionMatrix();         
            controls.handleResize();
            render();
         }       
         
         function consoleTextArrivedCallback(data)
         {
            console.log("new console text has arrived: " + data);
            
            //TODO: add it to text window here. 
            var textArea=document.getElementById("myTextarea");
            ;
            var n = data.indexOf("\n");
            if(n!=-1)
            {
               data = data.slice(0, n+1) + "> " + data.slice(n+1);         
               
            }
            textArea.value+=data;
            //var currentText=textArea.val();
          
            //textArea.val(currentText+data);
            textArea.scrollTop = textArea.scrollHeight;
         }
         
         function consoleErrorArrivedCallback(data)
         {            
            console.log("new console error has arrived: " + data);
            
            //TODO: add it to text window here. 
            var textArea=document.getElementById("myTextarea");
            textArea.value+=data;
            //var currentText=textArea.val();
          
            //textArea.val(currentText+data);
            textArea.scrollTop = textArea.scrollHeight;
         }
  
         function newSceneArrivedCallback(data)
         {   
            console.log("new scene has arrived!");
         
            var dataJ=JSON.parse(data); 

            //need to determine if full scene or just transforms
            var isFullScene=dataJ.metadata.fullscene;
         
            console.log("full scene is: " + isFullScene);
         
            if(isFullScene)
            {        
               var t0 = performance.now();
            
               //loader.setTexturePath( scope.texturePath );

            	var scope = this;
               var geometry;
               var material;
               
		         scene.traverse( function ( child ) { //make sure to dispose all old objects
   			      if ( child.geometry !== undefined ) child.geometry.dispose();
	               if ( child.material !== undefined ) child.material.dispose();
               } );
               scene=null;
            
               scene = loader.parse( dataJ );
               var t1 = performance.now();
               console.log("Call to load scene " + (t1 - t0) + " milliseconds.")
               //scene.traverse ( function (child) {
               //  console.log("found: " + child.name);
               //});
            }
            else //just apply transforms
            {
               var t0 = performance.now();
               var sceneObjects=dataJ.object;
           
               for(i=0; i<sceneObjects.length; i++)
               {  
                  //console.log("Update requested to: " + sceneObjects[i].name);
                  //console.log("  new matrix is: " + sceneObjects[i].matrix);
           
                  var object = scene.getObjectByName(sceneObjects[i].name, true );
                  if(object != null)
                  { 
                    //console.log("  we found \"" + sceneObjects[i].name + "\" in the Three.js scene");
                                   
                    object.matrixAutoUpdate=false;
                    object.matrixWorldNeedsUpdate=true;
                  
                    var m=sceneObjects[i].matrix;
               
                    object.matrix.set(m[0],m[4],m[8],m[12],m[1],m[5],m[9],m[13],m[2],m[6],m[10],m[14],m[3],m[7],m[11],m[15]);

                  } 
               } 
               var t1 = performance.now();
               console.log("Call to load tranforms " + (t1 - t0) + " milliseconds.");
            }
            
            var t1 = performance.now();

            var rpc =dataJ.RPC;
            for(i=0; i<rpc.length; i++)
            {  
               var request=rpc[i];
               if(request.type == "set_color") 
               {
                  var object_name=request.object;
                  var rgba=request.rgba;
                  var recursive=request.recursive;
                                                             
                  console.log("set_color requested. object: " + object_name + " rgba: " + rgba); 
                  
                             
                  var object = scene.getObjectByName(object_name, true );
                  if(object != null)
                  { 
                     console.log("we found the object in the tree");
                     //if(typeof object.material !== 'undefined')
                     //{
                      //  console.log("first checking if we've working this this material before");
                                                                        
                        if(recursive==false)
                        {
                           if(typeof object.userData.customSingleMaterialSetup === 'undefined')
                           {                          
                              basicMaterial = new THREE.MeshBasicMaterial();
                              object.material=basicMaterial;
                              object.userData.customSingleMaterialSetup=true;
                           }
                        }
                        else
                        {
                           if(typeof object.userData.customSharedMaterialSetup === 'undefined')
                           {                          
                              basicMaterial = new THREE.MeshBasicMaterial();
                              object.material=basicMaterial;
                              object.userData.customSharedMaterialSetup=true;
                              
                              object.traverse( function ( child ) { 
                              if (typeof child.material !== 'undefined') 
                                 child.material=object.material;
                              } );
                           }                        
                        }                    
                  
                        object.material.color.setRGB(rgba[0],rgba[1],rgba[2]);
                        if(rgba[3]!=1.0)
                        {
                           object.material.transparent=true;
                           object.material.opacity=rgba[3];
                        }
                        else
                        {
                           object.material.transparent=false;
                        }
                        console.log("succesfully set link color");
                     //}
                     //else
                     //{
                     //   console.log("ERROR: no material associated with object: " + object_name);  
                     //   alert("ERROR: kviz.set_color is trying to set an object with no material");
                     //}
                  }
               }
               if(request.type == "add_ghost") 
               {
                  var object_name=request.object;
                  var prefix=request.prefix_name;
                                                             
                  console.log("add_ghost requested. object: " + object_name + " prefix: " + prefix); 
                                               
                  var object = scene.getObjectByName(object_name, true );
                  if(object != null)
                  { 
                     console.log("we found the object in the tree");
                    
                     var clone_object=object.clone(true);
                     scene.add(clone_object);
                     
                     clone_object.traverse( function ( child ) { 
                              if (typeof child.name !== 'undefined') 
                                 child.name=prefix+child.name;
                              } );
                  }
               }
               if(request.type == "set_position")
               {                 
                  console.log("got a set_position RPC request for: " + request.object);
                  var object = scene.getObjectByName(request.object, true );
                  if(object != null)
                  {            
                    object.matrixAutoUpdate=false;
                    object.matrixWorldNeedsUpdate=true;
                  
                    var m=request.matrix;     
                    object.matrix.set(m[0],m[1],m[2],m[3],m[4],m[5],m[6],m[7],m[8],m[9],m[10],m[11],m[12],m[13],m[14],m[15]);
                  } 
                  else
                     console.log("  couldn't find object: " + request.object);
               }
               if(request.type == "add_text")
               {
                        
                  var text2 = document.createElement('div');
                  text2.style.position = 'absolute';
                  text2.id=request.name;
                  //text2.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
                  //text2.style.width = 100;
                  //text2.style.height = 100;
                  //text2.style.backgroundColor = "blue";
                  if(request.text!=null)
                     text2.innerHTML = request.text;
                     
                  text2.style.top = request.x + '%';
                  text2.style.left = request.y + '%';
                  document.getElementById("canvas").appendChild(text2);
               }
               if(request.type == "update_text")
               {
                  var text2 = document.getElementById(request.name);
                  text2.innerHTML = request.text;
               }
            }
            var t2 = performance.now();
            if(rpc.length > 0)
            {
               console.log("Call to do RPC's " + (t2 - t1) + " milliseconds.")
            }
            else
               console.log("no RPC's present");
            
            data=null;
            dataJ=null;
            rpc=null;
            
           
            var t0 = performance.now();
            render();
            var t1 = performance.now();
            console.log("Time to render " + (t1 - t0) + " milliseconds.")
            console.log("finished processing message");
            if(freeRun)
              requestAdvance();
         }
      
         function animate()
         {
            requestAnimationFrame( animate  );
            controls.update();
         }
  
         function render()
         {     
            //stats.begin();
            renderer.render( scene, camera );
            //stats.end();
         }
      </script>
   </body>
</html>
