# Klamp't Tutorial: Run a simulation with Python API
In this tutorial we learn how to run a simulation, interact with the simulated robot via the poser, and to simulate paths and trajectories. It is assumed that you have already successfully Install Klampt ([Linux](Documentation/Tutorials/Install-Linux.md),  [Windows](Documentation/Tutorials/Install-Windows.md),  [Mac](Documentation/Tutorials/Install-Mac.md))

Difficulty: easy

Time: 5 - 10 minutes

### Python Simulation

In this tutorial we'll make a Python simulation program with a GUI. We'll work from the template in Klampt/Python/demos/gltemplate.py. Open up the  [Python API documentation](http://motion.pratt.duke.edu/klampt/pyklampt_0.7_docs)  for reference while you are playing around.

First, copy Klampt/Python/demos/gltemplate.py to your own folder and rename it for example myapp.py. If you run
```
python myapp.py [path to Klampt]/Klampt/data/athlete_fractal_1.xml
```
and press 's', the simulation will proceed with the robot not doing anything. If you want to simulate while moving the robot around using the keyboard, you can work from Klampt/Python/demos/kbdrive.py.
### Sending milestones to the controller

Now, we will send the same leg lift and lower motion to the controller as we did in the C++ tutorial. Open myapp.py in a text editor. We'll be putting our code in the control_loop method under the comment "#Put your control handler here":
```
sim = self.sim
	if sim.getTime() >= 2.0 and sim.getTime()-self.dt < 2.0:
		q=sim.controller(0).getCommandedConfig()
        q[7]-=1.0
        sim.controller(0).setMilestone(q)
        q[7]+=1.5
        sim.controller(0).addMilestone(q)
```
Now run the simulation and see what happens.

### Sending a trajectory to the controller

Here we'll use a trajectory that's been saved to disk, using the klampt.trajectory module. Unlike the prior example, which used the controller's trajectory queue, we'll send this motion at a high rate to the robot using PID commands. (These override the controller's trajectory queue.)

First, we'll load the trajectory into a class variable by putting these lines at the end of the __init__ method:

        self.traj = trajectory.RobotTrajectory(self.world.robot(0))
        self.traj.load("../Klampt/data/motions/athlete_flex.path")

... and then we will put the following code in the control handler:

        sim = self.sim
        traj = self.traj
        starttime = 2.0
        if sim.getTime() > starttime:
            (q,dq) = (traj.eval(self.sim.getTime()-starttime),traj.deriv(self.sim.getTime()-starttime))
            sim.controller(0).setPIDCommand(q,dq)

That's it! For more information on controlling Python simulations, visit the  [Custom Controller Tutorial](Documentation/Tutorials/Custom-controller.md.md).

### Playing God: applying forces and constraining velocities

The robot controller is not able to apply arbitrary forces to its body or the world. This encapsulation is deliberate, because a robot cannot "play God" -- it can only affect its body or the world via its actuators. But it is often useful to generate simulation scenarios by "playing God," and to do so, you must access the SimBody elements that give you direct access to the rigid bodies in the underlying simulator.

The first step in doing so is to access the SimBody out of the Simulator corresponding to the desired object in the WorldModel. To do so, you would call something like this:
```
body = sim.body(world.robotlink(my_robot_index,my_link_index));
#or...
body = sim.body(world.rigidObject(my_object_index));
```
To apply forces, you may use the SimBody.applyForceAtPoint function as follows:
```
body.applyForceAtPoint([fx,fy,fz],[px,py,pz]);
```
Where the force (fx,fy,fz) and point (px,py,pz) are in world coordinates. You may also call SimBody.applyWrench to apply a force/torque about the center of mass.

Directly controlling the movement of a body (e.g., to move along a predetermined path, or according to a joystick) is possible but takes a few extra steps, because Klamp't by default gives control of the body to the simulator. First, you will need to know the translational and angular velocity along which the body should be moving at each time step. Let us assume you have determined these quantities as (vx,vy,vz) and (wx,wy,wz); both are in world coordinates. Then, you will need to disable dynamic simulation, and during your time step you will need to set the velocities directly as follows:
```
body.enableDynamics(False)
body.setVelocity((wx,wy,wz),(vx,vy,vz))
```
Note the angular velocity is provided as the first argument.

### Extracting contact forces

For research and evaluation purposes it is often useful to record the contact forces generated by the simulation, and Klamp't provides several functions for doing so. This tutorial also illuminates some of the differences between the indexing and body ID schemes.

The first step in extracting contact feedback is to enable it. Contact feedback is enabled on a per body pair basis; this is primarily done to save a little overhead in computation and memory. Each rigid body in the world, including environment objects and robot links, is given a unique ID, and this ID is used to identify the corresponding body in the simulator. To get the ID of an object in the world you call getID() on it:
```
terrainid = world.terrain(terrain_index).getID()
objectid = world.rigidObject(object_index).getID()
linkid = world.robot(robot_index).link(link_index).getID()
#equivalent to
linkid = world.robotlink(robot_index,link_index).getID()
```
IDs are constant throughout the life of the simulation. (NOTE: IDs will change if you add or remove elements from the world -- this is not yet supported in simulation.) We can then just do something like this to enable only collision feedback between the terrain and all links on the robot:
```
for i in range(world.robot(robot_index).numLinks())
  sim.enableContactFeedback(terrainid,world.robotlink(robot_index,i).getID())
```
IDs are assigned contiguously, and hence it is possible to just loop through integers ranging from 0 to world.numIDs()-1 to enable all contact pairs (Don't worry, the computational overhead is not that high). This is done frequently, so we have a convenience function
```
sim.enableContactFeedbackAll()
```
Let's assume we added the above line to our code. Then, during the simulation loop, we can use the following code to see what objects are in contact. We can also print out the latest force/torque:
```
contacted=False
for i in range(world.numIDs()):
  for j in range(i+1,world.numIDs()):
    #you could loop over a selective set of id pairs rather than i and j, if you wanted...
    if sim.inContact(i,j):
      if not contacted:
        print "Touching bodies:"
        contacted=True
      f = sim.contactForce(i,j)
      t = sim.contactTorque(i,j)
      print " ",world.getName(i),"-",world.getName(j),"contact force",f,"and torque",t
```
Even more detailed information about the latest contact points can be retrieved using the sim.getContacts() function. This returns a list of 7-lists, each of which contains the 3D contact point, 3D contact normal, and the friction coefficient. So the following code would print out all contacts between the given objects:
```
contactlist = sim.getContacts(objectid,linkid)
for c in contactlist:
  print "Contact point",c[0:3],"normal",c[3:6],"friction coefficient",c[6]
```