# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


"""
Python interface to KrisLibrary motion planing routines
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_motionplanning', [dirname(__file__)])
        except ImportError:
            import _motionplanning
            return _motionplanning
        if fp is not None:
            try:
                _mod = imp.load_module('_motionplanning', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _motionplanning = swig_import_helper()
    del swig_import_helper
else:
    import _motionplanning
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0



def setRandomSeed(*args):
  """
    setRandomSeed(int seed)

    void setRandomSeed(int seed)

    Sets the random seed used by the motion planner. 
    """
  return _motionplanning.setRandomSeed(*args)

def setPlanType(*args):
  """
    setPlanType(char type)

    void setPlanType(const char
    *type)

    Sets the planner type.

    Valid values are "prm": Probabilistic roadmap

    "rrt": Rapidly-exploring Random Trees

    "sbl": The SBL (single-query, bidirectional, lazy) planner 
    """
  return _motionplanning.setPlanType(*args)

def setPlanSetting(*args):
  """
    setPlanSetting(char setting, double value)

    void setPlanSetting(const char
    *setting, double value)

    Sets a setting for the planner.

    Valid values are "knn": k value for the k-nearest neighbor
    connection strategy (only for PRM)

    "connectionThreshold": a milestone connection threshold

    "perturbationRadius": (only for RRT and SBL)

    "bidirectional": 1 if bidirectional planning is requested (only for
    RRT)

    "grid": 1 if a point selection grid should be used (only for SBL)

    "gridResolution": resolution for the grid, if the grid should be
    used

    "randomizeFrequency": a grid randomization frequency (only for SBL)

    """
  return _motionplanning.setPlanSetting(*args)

def destroy():
  """
    destroy()

    void destroy()

    destroys internal data structures 
    """
  return _motionplanning.destroy()
class CSpaceInterface(_object):
    """
    A raw interface for a configuration space. The CSpace interface in
    cspace.py is easier to use.

    C++ includes: motionplanning.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSpaceInterface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSpaceInterface, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> CSpaceInterface
        __init__(self, CSpaceInterface arg0) -> CSpaceInterface

        CSpaceInterface::CSpaceInterface(const CSpaceInterface &) 
        """
        this = _motionplanning.new_CSpaceInterface(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _motionplanning.delete_CSpaceInterface
    __del__ = lambda self : None;
    def destroy(self):
        """
        destroy(self)

        void
        CSpaceInterface::destroy() 
        """
        return _motionplanning.CSpaceInterface_destroy(self)

    def setFeasibility(self, *args):
        """
        setFeasibility(self, PyObject pyFeas)

        void
        CSpaceInterface::setFeasibility(PyObject *pyFeas) 
        """
        return _motionplanning.CSpaceInterface_setFeasibility(self, *args)

    def setVisibility(self, *args):
        """
        setVisibility(self, PyObject pyVisible)

        void
        CSpaceInterface::setVisibility(PyObject *pyVisible) 
        """
        return _motionplanning.CSpaceInterface_setVisibility(self, *args)

    def setVisibilityEpsilon(self, *args):
        """
        setVisibilityEpsilon(self, double eps)

        void
        CSpaceInterface::setVisibilityEpsilon(double eps) 
        """
        return _motionplanning.CSpaceInterface_setVisibilityEpsilon(self, *args)

    def setSampler(self, *args):
        """
        setSampler(self, PyObject pySamp)

        void
        CSpaceInterface::setSampler(PyObject *pySamp) 
        """
        return _motionplanning.CSpaceInterface_setSampler(self, *args)

    def setNeighborhoodSampler(self, *args):
        """
        setNeighborhoodSampler(self, PyObject pySamp)

        void
        CSpaceInterface::setNeighborhoodSampler(PyObject *pySamp) 
        """
        return _motionplanning.CSpaceInterface_setNeighborhoodSampler(self, *args)

    def setDistance(self, *args):
        """
        setDistance(self, PyObject pyDist)

        void
        CSpaceInterface::setDistance(PyObject *pyDist) 
        """
        return _motionplanning.CSpaceInterface_setDistance(self, *args)

    def setInterpolate(self, *args):
        """
        setInterpolate(self, PyObject pyInterp)

        void
        CSpaceInterface::setInterpolate(PyObject *pyInterp) 
        """
        return _motionplanning.CSpaceInterface_setInterpolate(self, *args)

    __swig_setmethods__["index"] = _motionplanning.CSpaceInterface_index_set
    __swig_getmethods__["index"] = _motionplanning.CSpaceInterface_index_get
    if _newclass:index = _swig_property(_motionplanning.CSpaceInterface_index_get, _motionplanning.CSpaceInterface_index_set)
CSpaceInterface_swigregister = _motionplanning.CSpaceInterface_swigregister
CSpaceInterface_swigregister(CSpaceInterface)

class PlannerInterface(_object):
    """
    An interface for a motion planner. The MotionPlanner interface in
    cspace.py is somewhat easier to use.

    On construction, uses the planner type specified by setPlanType and
    the settings currently specified by calls to setPlanSetting.

    Point-to-point planning is enabled using the setEndpoints method. This
    is mandatory for RRT and SBL planners. The start and end milestones
    are given by indices 0 and 1, respectively

    PRM can be used in either point-to-point or multi-query mode. In
    multi-query mode, you may call addMilestone(q) to add a new milestone.
    addMilestone() returns the index of that milestone, which can be used
    in later calls to getPath().

    To plan, call planMore(iters) until getPath(0,1) returns non-NULL. The
    return value is a list of configurations.

    To get a roadmap dump, call dump(fn). This saves to a Trivial Graph
    Format (TGF) format.

    C++ includes: motionplanning.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlannerInterface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PlannerInterface, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, CSpaceInterface cspace) -> PlannerInterface

        PlannerInterface::PlannerInterface(const CSpaceInterface &cspace) 
        """
        this = _motionplanning.new_PlannerInterface(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _motionplanning.delete_PlannerInterface
    __del__ = lambda self : None;
    def destroy(self):
        """
        destroy(self)

        void
        PlannerInterface::destroy() 
        """
        return _motionplanning.PlannerInterface_destroy(self)

    def setEndpoints(self, *args):
        """
        setEndpoints(self, PyObject start, PyObject goal) -> bool

        bool
        PlannerInterface::setEndpoints(PyObject *start, PyObject *goal) 
        """
        return _motionplanning.PlannerInterface_setEndpoints(self, *args)

    def addMilestone(self, *args):
        """
        addMilestone(self, PyObject milestone) -> int

        int
        PlannerInterface::addMilestone(PyObject *milestone) 
        """
        return _motionplanning.PlannerInterface_addMilestone(self, *args)

    def planMore(self, *args):
        """
        planMore(self, int iterations)

        void
        PlannerInterface::planMore(int iterations) 
        """
        return _motionplanning.PlannerInterface_planMore(self, *args)

    def getPathEndpoints(self):
        """
        getPathEndpoints(self) -> PyObject

        PyObject *
        PlannerInterface::getPathEndpoints() 
        """
        return _motionplanning.PlannerInterface_getPathEndpoints(self)

    def getPath(self, *args):
        """
        getPath(self, int milestone1, int milestone2) -> PyObject

        PyObject *
        PlannerInterface::getPath(int milestone1, int milestone2) 
        """
        return _motionplanning.PlannerInterface_getPath(self, *args)

    def getData(self, *args):
        """
        getData(self, char setting) -> double

        double
        PlannerInterface::getData(const char *setting) 
        """
        return _motionplanning.PlannerInterface_getData(self, *args)

    def dump(self, *args):
        """
        dump(self, char fn)

        void
        PlannerInterface::dump(const char *fn) 
        """
        return _motionplanning.PlannerInterface_dump(self, *args)

    __swig_setmethods__["index"] = _motionplanning.PlannerInterface_index_set
    __swig_getmethods__["index"] = _motionplanning.PlannerInterface_index_get
    if _newclass:index = _swig_property(_motionplanning.PlannerInterface_index_get, _motionplanning.PlannerInterface_index_set)
PlannerInterface_swigregister = _motionplanning.PlannerInterface_swigregister
PlannerInterface_swigregister(PlannerInterface)

# This file is compatible with both classic and new-style classes.


